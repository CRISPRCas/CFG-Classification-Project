import os
import json
from openai import OpenAI
import time
from lark import Lark, UnexpectedInput


def parse_string(input_string, grammar):
    # Define Lark parser with the provided grammar
    parser = Lark(grammar, start='start', parser='earley')
    
    # Try to parse the string
    try:
        parser.parse(input_string)
        return True  # Accepted
    except UnexpectedInput:
        return False  # Not accepted

class CFGAcceptanceExperiment:
    def __init__(self, model: str = "gpt-3.5-turbo"):
        """
        Initializes the CFGAcceptanceExperiment instance.

        Parameters:
        model (str): The model to be used for the experiment.
        """
        self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
        self.model = model

    def cfg_acceptance_checker(self, cfg: str, string: str) -> dict:
        """
        Uses the OpenAI API to determine if a string can be generated by a given CFG.

        Parameters:
        cfg (str): The context-free grammar rules.
        string (str): The string to be checked.

        Returns:
        dict: A dictionary containing 'result' (True/False), 'raw_response' (API response), and 'error' (if any).
        """
        # Construct the messages for the chat-based completion
        # Reason2Conclude
        # messages = [
        #     {
        #         "role": "system",
        #         "content": "You are a CFG analyzer that determines if a string can be derived from a given context-free grammar.",
        #     },
        #     {
        #         "role": "user",
        #         "content": f"""
        #         Task: Determine if the given string can be derived from the following CFG.

        #         Context-Free Grammar (CFG):
        #         {cfg}

        #         String to Check:
        #         "{string}"

        #         Follow the CFG rules exactly and return 'True' if the string can be derived, else 'False'.
        #         """,
        #     },
        # ]
        # PureGuess
        # messages = [
        #     {
        #         "role": "system",
        #         "content": "You are a guesser that determines if a string can be derived from a given context-free grammar (CFG) purely based on instinct, without any reasoning or analysis.",
        #     },
        #     {
        #         "role": "user",
        #         "content": f"""
        #         Task: Make a guess whether the given string can be derived from the following CFG.

        #         Context-Free Grammar (CFG):
        #         {cfg}

        #         String to Check:
        #         "{string}"

        #         Return 'True' or 'False' based solely on your guess. No reasoning is required.
        #         """,
        #     },
        # ]
        # Guess2Explain
        # messages = [
        #     {
        #         "role": "system",
        #         "content": "You are a guesser that determines if a string can be derived from a given context-free grammar (CFG). First, make a guess, and then provide an explanation for your guess.",
        #     },
        #     {
        #         "role": "user",
        #         "content": f"""
        #         Task: First make a guess whether the given string can be derived from the following CFG.

        #         Context-Free Grammar (CFG):
        #         {cfg}

        #         String to Check:
        #         "{string}"

        #         Return 'True' or 'False' based on your guess. After that, explain the reasoning behind your guess.
        #         """,
        #     },
        # ]
        # Function Calling
        messages = [
            {
                "role": "system",
                "content": "You are a proficient tool-using decider that determines if a string can be derived from a given context-free grammar (CFG). Whenever possible, call the provided function to obtain accurate results rather than relying on your own reasoning. The function only accpet lark grammar. To standardize grammar notation in the Lark Parser format, apply the following conventions: 1. Start Symbol Naming: Using `start` as the designated entry point for the grammar. 2. Non-terminal Naming Convention: Convert all non-terminal symbols to **LOWERCASE**. Each non-terminal should be named with lowercase letters only, reflecting the grammatical hierarchy and structure. 3. Terminal Notation: Enclose all terminal symbols in **DOUBLE QUOTES (\")**, not the single quotes (\'). This ensures consistency and clarity in differentiating terminals from non-terminals. 4. Symbol Separation: Use whitespace to separate all symbols within rules. This applies to both terminals and non-terminals, ensuring readability and uniform spacing throughout the grammar definition. For example, you need to rewrite the grammar ```S -> aS | b``` as ```start: s\ns: \"a\" s | \"b\"```. Think step by step as the following: 1. Identify all terminal symbols in the grammar. 2. Identify all non-terminal symbols in the grammar. 3. Rewrite each rule according to the given grammar rules and the Lark syntax conventions to ensure compliance with the Lark format. 4. Call the given function. 5. Give out True or False according to the function output.",
            },
            {
                "role": "user",
                "content": f"""
                Task: Decide whether the given string can be derived from the following CFG.

                Context-Free Grammar (CFG):
                {cfg}

                String to Check:
                "{string}"

                Return 'True' or 'False' based solely on the function calling. No reasoning is required.
                """,
            },
        ]
        functions = [
            {
                "name": "parse_string",
                "description": "Check if the input string is accepted by the given CFG grammar",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "input_string": {
                            "type": "string",
                            "description": "The string to be checked against the grammar."
                        },
                        "grammar": {
                            "type": "string",
                            "description": "The CFG grammar in Lark format"
                        },
                    },
                    "required": ["input_string", "grammar"],
                },
            },
        ]
        try:
            # Call the OpenAI chat completions API
            response = self.client.chat.completions.create(
                messages=messages,
                model=self.model,
                functions=functions,
                function_call="auto",
            )
            if response.choices[0].message.function_call:
                print("======= CALL THE FUNCTION! =======")
                function_name = response.choices[0].message.function_call.name
                function_args = json.loads(response.choices[0].message.function_call.arguments)
                # print(function_args)

                if function_name == "parse_string":
                    # print("======= CALL `parse_string` =======")
                    result = parse_string(function_args["input_string"].replace("\"", ""), function_args["grammar"].replace("\'", "\""))

                messages.append(
                    {
                        "role": "function",
                        "name": function_name,
                        "content": json.dumps(result),
                    }
                )
                second_response = self.client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                )

                final_message = second_response.choices[0].message.content.strip()
            else:
                final_message = response.choices[0].message.content.strip()
            # Extract and clean the raw response
            raw_response = final_message
            # Check for 'true' and 'false' in the response
            if "true" in raw_response.lower() and "false" in raw_response.lower():
                result = None  # Both True and False exist in the response
            elif "true" in raw_response.lower():
                result = True
            elif "false" in raw_response.lower():
                result = False
            else:
                result = None  # Neither True nor False found
            return {
                "result": result,
                "raw_response": raw_response,
                "error": None,
            }
        except Exception as e:
            # Handle any exception that occurred during the API call
            return {
                "result": None,
                "raw_response": None,
                "error": str(e),
            }

    def run_experiment(self, test_cases: list):
        """
        Runs the experiment with a given set of test cases.

        Parameters:
        test_cases (list): A list of test cases, where each test case is a dictionary with 'cfg' and 'string'.

        Yields:
        dict: The result for each test case, including the raw API response.
        """
        retry_delay = 1  # Initial delay in seconds
        for i, case in enumerate(test_cases):
            success = False
            while not success:
                try:
                    print(f"Running test case {i + 1}/{len(test_cases)}...")
                    result = self.cfg_acceptance_checker(
                        case["cfg"], case["string"]
                    )
                    yield {
                        "cfg": case["cfg"],
                        "string": case["string"],
                        "label": case["label"],
                        "result": result["result"],
                        "raw_response": result["raw_response"],
                        "error": result["error"],
                    }
                    success = True
                except Exception as e:
                    print(
                        f"Error encountered: {e}. Retrying in {retry_delay} seconds..."
                    )
                    time.sleep(retry_delay)
                    retry_delay *= 2  # Exponential backoff
                    if retry_delay > 128:
                        return None


# 使用示例：
if __name__ == "__main__":
    # Initialize the experiment with the model
    experiment = CFGAcceptanceExperiment(model="gpt-3.5-turbo")

    # Define a list of test cases
    test_cases = [
        {
            "cfg": """
            S -> aSb | ε
            """,
            "string": "aabb",
            "label": True,
        },
        {
            "cfg": """
            S -> aS | b
            """,
            "string": "aaab",
            "label": True,
        },
        {
            "cfg": """
            S -> AB
            A -> aA | ε
            B -> bB | ε
            """,
            "string": "aabbb",
            "label": True,
        },
    ]

    # Run the experiment
    for result in experiment.run_experiment(test_cases):
        # Print the result of each test case as it is processed
        print(f"\nTest Case:")
        print(f"CFG: {result['cfg']}")
        print(f"Input String: {result['string']}")
        print(f"Parsed Result: {result['result']}")
        print(f"Raw Response: {result['raw_response']}")
        print(f"Error: {result['error']}")
